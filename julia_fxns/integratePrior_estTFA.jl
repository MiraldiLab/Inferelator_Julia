## integratePrior_estTFA(geneExprMat,priorFile,edgeSS,...
#      minTargets, tfaOutMat)
## GOALS: 
#Integrate prior information with gene expression data for
#   1. TRN inference based on TF mRNA
#   2. TRN inference based on prior-based TFA with the following equation:
#                         X = P * A,    [Equation 1]
# where P  [genes X TFs] is the prior matrix of known TF-gene interactions, 
# X  [genes X samples] is the expression matrix for genes in the prior
# A  [TFs X samples] contains the unknown protein activities for TFs in the
# prior. There is no unique solution to Equation 1, but the least-squares
# solution works well in practice (Ortiz et al. (2015) Molec. Sys. Bio.)
# The robustness is improved by subsampling the edges of P, 
# solving for A multiple times and taking the median
## INPUTS:
# geneExprMat -- .mat file of gene expression and gene lists for TFA 
#   estimation (e.g., as generated by importGeneExprGeneLists.m)
# priorFile -- a prior in table form, rows = genes, columns = regulators
# edgeSS -- number of prior edge subsamples, NOTE: if edgeSS = 0, no 
#   subsampling will occur and all edges will be used to calculate TFA
# minTargets -- minimum number of targets per TF to stay in prior
# tfaOutMat -- filename for TFA output .mat
## OUTPUTS:
# tfaOutMat -- whos
#   medTfas                 341x254              692912  double              
#   noPriorRegs             369x1                 45554  cell                
#   noPriorRegsMat          369x254              749808  double              
#   pRegs                   341x1                 41542  cell                
#   pRegsNoTfa              346x1                 41996  cell                
#   pTargs                14485x1               1792680  cell                
#   pTargsNoTfa           14513x1               1796176  cell                
#   priorMatrix           14485x341            39515080  double              
#   priorMatrixNoTfa      14513x346            40171984  double 
## NOTE (!!): If there are TFs with identical targets in the prior, it is
# assumed that there is also a second priorFile (specifically, 
# mergedFile = strrep(priorFile,'.tsv','_merged.tsv') and associated file
# mergedTFs = strrep(priorFile,'.tsv','_mergedTFs.txt') to decode gene
# names of merged TFs, as can be generated by mergeDegeneratePriorTFs.py 
# in the priorParsingFxns folder associated with this repo)
## Reference:
# Miraldi et al. "Leveraging chromatin accessibility for 
#   transcriptional regulatory network inference in T Helper 17 Cells"
## Author: Emily R. Miraldi, Ph.D., Divisions of Immunobiology and Biomedical
#   Informatics, Cincinnati Children's Hospital
using JLD2
using DelimitedFiles
using Random
using Statistics
using CSV
using TickTock

function integratePrior_estTFA(geneExprMat, priorFile, minTargets, edgeSS, outputFile)

## load files
println("Loading in data")
targGeneMat = load(geneExprMat, "targGeneMat")
tfaGeneMat = load(geneExprMat, "tfaGeneMat")
potRegMat_mRNA = load(geneExprMat, "potRegMat_mRNA")
potRegs_mRNA = load(geneExprMat, "potRegs_mRNA")

totGenes = size(targGeneMat)[1]
totConds = size(targGeneMat)[2]

println("Case 1")

# Open prior file
fid = open(priorFile)
C = readdlm(fid,'\t','\n', skipstart=0)

# Store first row (the TFs) in a vector pRegsTmp
pRegsTmp = C[1,:]

# If first entry is empty, remove it (depends on formatting)
pRegsTmp = filter(!isempty, pRegsTmp)

# Convert the pRegsTmp vector to type string for speed purposes 
pRegsTmp = convert(Vector{String}, pRegsTmp)

# Store remaining prior matrix (minus column names) as a matrix
C = C[2:end,:]

# Sort prior gene vector alphebetically. Resort the matrix as well
inds = sortperm(C[:,1])
C = C[inds,:]

# Store genes in prior matrix in vector pTargsTmp. Convert it to type String for speed
pTargsTmp = C[:,1]
pTargsTmp = convert(Vector{String}, pTargsTmp)

# Store the matrix of sorted prior matrix counts. Convert it to Float
pIntsTmp = C[:,2:end]
pIntsTmp = convert(Matrix{Float64}, pIntsTmp)
close(fid)



## Limit prior regulators and gene targets to those included in input data
# load TF list
potRegs = load(geneExprMat, "potRegs")
# load genes used for TFA 
tfaGenes = load(geneExprMat, "tfaGenes")

# Find which prior TFs (columns) are in TF list
pRegsIndsTmp = findall(in(potRegs), pRegsTmp)
# Find which prior genes (rows) are in TFA genes
pTargIndsTmp = findall(in(tfaGenes),pTargsTmp)
# Find which TFs in our list are also in the prior
pRegsNoTfa = intersect(pRegsTmp, potRegs)
# Find which TFA genes are also in the prior
pTargsNoTfa = intersect(pTargsTmp, tfaGenes)
pTargsNoTfa = convert(Vector{String}, pTargsNoTfa)
pRegsNoTfa = convert(Vector{String}, pRegsNoTfa)

# Subset prior matrix to include only relavant TFs and genes. This matrix is missing the TFs
# that were not in the prior
priorMatrixNoTfa = pIntsTmp[pTargIndsTmp, pRegsIndsTmp]

# Find TFs that have expression data but arent in the prior 
noPriorRegs = setdiff(potRegs_mRNA,pRegsNoTfa)
# Get the row number of where the noPriorRegs occur in TF expression matrix
expInds = findall(in(noPriorRegs), potRegs_mRNA)
# Create matrix of gene expression for the TFs that wernt in prior 
noPriorRegsMat = potRegMat_mRNA[expInds,:]

println("Case 2")
## Case 2: prior-based TFA is used
# Check whether there were degenerate TFs and outputs from e.g.,
# mergeDegenreatePriorTFs.py exist
mergedTFsExist = 1
mergedFile = replace(priorFile,".tsv" =>"_merged.tsv")
mergedTFs = replace(priorFile,".tsv" => "_mergedTfs.txt")
file1 = isfile(mergedFile)
file2 = isfile(mergedTFs)
if(file1 == false || file2 == false)   
    mergedTFsExist = 0
end

if mergedTFsExist == 1
    mtIn = open(mergedTFs)
    C = readdlm(mtIn,'\t','\n', skipstart=0)
    #C = CSV.File(mtIn, delim="\t", header=0)
    mergedTFs = C[:,1]
    individualTFs = C[:,2] 
    mergedTFs = convert(Vector{String}, mergedTFs)
    individualTFs = convert(Vector{String}, individualTFs)
    totMergedSets = length(individualTFs);
    keepMergedTFs = []; # keep track of merged TF names to keep
    for mind = 1:totMergedSets
        currSet = split(individualTFs[mind],", ")
        usedTfs = intersect(currSet,potRegs)
        if length(usedTfs) > 0 
            keepMergedTFs = [keepMergedTFs; mind]
        end
    end
    if length(keepMergedTFs) > 0 # add merged potential regulators to our list       
        potRegs = union(potRegs,mergedTFs[keepMergedTFs])
        priorFile = mergedFile
        # regulator list and target genes
        fid = open(priorFile)
        # get first line and see what regulators we have    
        tline = readline(fid)
        pRegsTmp = split(tline,"\t")
        pRegsTmp = pRegsTmp[2:length(pRegsTmp)]
        #pRegsTmp = convert(Vector{String, pRegsTmp})
        totPRegs = length(pRegsTmp)        
        fid = open(priorFile)
        C = readdlm(fid,'\t',skipstart=0)
        pTargsTmp = C[:,1]
        pTargsTmp = pTargsTmp[2:length(pTargsTmp)]
        pTargsTmp = convert(Vector{String}, pTargsTmp)
        pIntsTmp = C[2:end,2:end]  
        pIntsTmp = convert(Matrix{Float64},pIntsTmp)
    end        
end 

println("Enforce Rules on data")

## Limit prior regulators and gene targets to those included in input data (.mat)
# Prior regs are all the TFs in TF list AND in the prior
pRegs = intersect(pRegsTmp,potRegs)
# Prior targs are all the TFs in gene list AND in the prior
pTargs = intersect(pTargsTmp,tfaGenes)

# pTargsTmp are genes in the prior. Find which of these should are also in the
# list of user inputted TFA genes (likely will be all). 
pTargIndsTmp = findall(in(tfaGenes), pTargsTmp)
# pRegIndsTmp are regs in prior. Find which ones are also in TF list
pRegIndsTmp = findall(in(potRegs), pRegsTmp)

# pInts is the subset prior matrix containing only TFs in potRegs and genes in TFA gene list
# pInts is still missing all the potRegs that wernt in the prior. Will be identical to priorMatrixNoTFA
# unless there were merged TFs 
pInts = pIntsTmp[pTargIndsTmp,pRegIndsTmp]
intsPerTf = sum((abs.(sign.(pInts))), dims=1)

## remove predictors that have fewer than the specified minimum number of targets
minTargets = max(minTargets,0)
keepRegs = Tuple.(findall(x -> x > minTargets, intsPerTf))
keepRegs = last.(keepRegs)
pInts = pInts[:,keepRegs]
pRegs = pRegs[keepRegs]

# possible that there now are some target genes with no regulators
intsPerTarg = sum(abs.(sign.(pInts)), dims = 2)
keepTargs = Tuple.(findall(x -> x > 0, intsPerTarg))
keepTargs = first.(keepTargs)
pInts = pInts[keepTargs,:]
pTargs = pTargs[keepTargs]

# make sure that target indices in prior and expression matrix
# coordinate. To calculate TFA, need the same set of genes in expression
# matrix and prior matrix

# pTargs2 are the prior genes also in list of TFA genes. This step should be not necessary
pTargs2 = intersect(pTargs,tfaGenes)
# Get the proper index order so pTargs mataches tfaGenes
pTargs2Inds = Tuple.(findall(in(tfaGenes), pTargs))
pTargIndsTmp = first.(pTargs2Inds)
expTargInds = Tuple.(findall(in(pTargs), tfaGenes))
expTargInds = first.(expTargInds)
priorMatrix = pInts[pTargIndsTmp,:]
priorMatrix = convert(Matrix{Float64}, priorMatrix)
# get target gene matrix
targExp = tfaGeneMat[expTargInds,:]
targExp = convert(Matrix{Float64}, targExp)

# priorMatrix and targExp now contain the same genes in the same order and can be 
# used to calculate TFA

println("Calculate TFA")
## calculate TFA, ( X = P * A, A = P \ X)
totTargs = size(priorMatrix)[1]
totPreds = size(priorMatrix)[2]


if edgeSS > 0
    tfas = zeros(edgeSS,totPreds,totConds)
    for ss = 1:edgeSS
        sPrior = zeros(Float64, totTargs,totPreds)
        for col = 1:totPreds
            currTargs = priorMatrix[:,col]
            targInds = findall(x -> x != 0, currTargs)
            totCurrTargs = length(targInds)
            # Create a vector from 1:totCurrTargs (the number of nonzero rows in the column) and shuffle it
            # Then take the first .63*totCurrTargs elements of this vector
            # Use this as the indices of targInds to create the ssample vector
            totCurrTargsVec = shuffle(collect(1:totCurrTargs))
            totCurrTargsVec = totCurrTargsVec[1:Int64(ceil(.63*totCurrTargs))]
            ssample = targInds[totCurrTargsVec]
            sPrior[ssample,col] = priorMatrix[ssample,col]
        end        
        tfas[ss,:,:] = sPrior \ targExp   
    end
    medTfas = zeros(totPreds,totConds)
    medTfas[:,:] = median(tfas, dims = 1)
    println("Median from  ", string(edgeSS), " subsamples used for prior-based TFA.")
else
    # Calculate TFA by dividing priorMatrix by targExp
    medTfas = priorMatrix \ targExp;
    println("No subsampling for prior-based TFA estimate.")
end


println("Save data")

# pTargsNoTfa: TFA genes also in the prior
# priorMatrixNoTFA: Prior matrix containing only TFA genes and potRegs. Missing potRegs not in prior
# pRegsNoTfa: potRegs also in the prior
# medTfas: TFA matrix. Missing potRegs not in prior
# pRegs: All TFs that are in the prior
# pTargs: All genes that are in the prior
# priorMatrix: Final prior matrix with order (pTargs, pRegs)
# noPriorRegs: potRegs not found in prior. Missing in current TFA matrix
# noPriorRegsMat: Gene expression for the missing TFs

@save outputFile pTargsNoTfa priorMatrixNoTfa pRegsNoTfa medTfas pRegs pTargs priorMatrix noPriorRegs noPriorRegsMat
end
