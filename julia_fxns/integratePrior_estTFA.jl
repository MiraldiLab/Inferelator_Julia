## integratePrior_estTFA(geneExprMat,priorFile,edgeSS,...
#      minTargets, tfaOutMat)
## GOALS: 
#Integrate prior information with gene expression data for
#   1. TRN inference based on TF mRNA
#   2. TRN inference based on prior-based TFA with the following equation:
#                         X = P * A,    [Equation 1]
# where P  [genes X TFs] is the prior matrix of known TF-gene interactions, 
# X  [genes X samples] is the expression matrix for genes in the prior
# A  [TFs X samples] contains the unknown protein activities for TFs in the
# prior. There is no unique solution to Equation 1, but the least-squares
# solution works well in practice (Ortiz et al. (2015) Molec. Sys. Bio.)
# The robustness is improved by subsampling the edges of P, 
# solving for A multiple times and taking the median
## INPUTS:
# geneExprMat -- .mat file of gene expression and gene lists for TFA 
#   estimation (e.g., as generated by importGeneExprGeneLists.m)
# priorFile -- a prior in table form, rows = genes, columns = regulators
# edgeSS -- number of prior edge subsamples, NOTE: if edgeSS = 0, no 
#   subsampling will occur and all edges will be used to calculate TFA
# minTargets -- minimum number of targets per TF to stay in prior
# tfaOutMat -- filename for TFA output .mat
## OUTPUTS:
# tfaOutMat -- whos
#   medTfas                 341x254              692912  double              
#   noPriorRegs             369x1                 45554  cell                
#   noPriorRegsMat          369x254              749808  double              
#   pRegs                   341x1                 41542  cell                
#   pRegsNoTfa              346x1                 41996  cell                
#   pTargs                14485x1               1792680  cell                
#   pTargsNoTfa           14513x1               1796176  cell                
#   priorMatrix           14485x341            39515080  double              
#   priorMatrixNoTfa      14513x346            40171984  double 
## NOTE (!!): If there are TFs with identical targets in the prior, it is
# assumed that there is also a second priorFile (specifically, 
# mergedFile = strrep(priorFile,'.tsv','_merged.tsv') and associated file
# mergedTFs = strrep(priorFile,'.tsv','_mergedTFs.txt') to decode gene
# names of merged TFs, as can be generated by mergeDegeneratePriorTFs.py 
# in the priorParsingFxns folder associated with this repo)
## Reference:
# Miraldi et al. "Leveraging chromatin accessibility for 
#   transcriptional regulatory network inference in T Helper 17 Cells"
## Author: Emily R. Miraldi, Ph.D., Divisions of Immunobiology and Biomedical
#   Informatics, Cincinnati Children's Hospital
using JLD2
using DelimitedFiles
using Random
using Statistics
using CSV
using TickTock

function integratePrior_estTFA(geneExprMat, priorFile, minTargets, edgeSS, outputFile)

## load input gene expression
println("Loading in data")
targGeneMat = load(geneExprMat, "targGeneMat")
tfaGeneMat = load(geneExprMat, "tfaGeneMat")
potRegMat_mRNA = load(geneExprMat, "potRegMat_mRNA")
potRegs_mRNA = load(geneExprMat, "potRegs_mRNA")

totGenes = size(targGeneMat)[1]
totConds = size(targGeneMat)[2]

println("Case 1")
## Case 1: TF mRNA, use the unmerged prior, limit prior to potential 
#fid = open(priorFile)
# get first line and see what regulators we have
#tline = readline(fid, keep=false)
#pRegsTmp = split(tline, '\t')
#if pRegsTmp[1] == ""
#    pRegsTmp = pRegsTmp[2:end]
#end
#close(fid)

# get the rest of the data using readdlm
#fid = open(priorFile)
#C = readdlm(fid,'\t','\n', skipstart=1)
#close(fid)
#pTargsTmp = C[:,1]
#pIntsTmp = C[:,2:end]

fid = open(priorFile)
C = readdlm(fid,'\t','\n', skipstart=0)
pRegsTmp = C[1,:]
if pRegsTmp[1] == ""
    pRegsTmp = pRegsTmp[2:end]
end
pRegsTmp = convert(Vector{String}, pRegsTmp)
C = C[2:end,:]
pTargsTmp = C[:,1]
pTargsTmp = convert(Vector{String}, pTargsTmp)
pIntsTmp = C[:,2:end]
pIntsTmp = convert(Matrix{Float64}, pIntsTmp)
close(fid)



## Limit prior regulators and gene targets to those included in input data
potRegs = load(geneExprMat, "potRegs")
tfaGenes = load(geneExprMat, "tfaGenes")
pRegsIndsTmp = findall(in(potRegs), pRegsTmp)
pTargIndsTmp = findall(in(tfaGenes),pTargsTmp)
pRegsNoTfa = intersect(pRegsTmp, potRegs)
pTargsNoTfa = intersect(pTargsTmp, tfaGenes)
pTargsNoTfa = convert(Vector{String}, pTargsNoTfa)
priorMatrixNoTfa = pIntsTmp[pTargIndsTmp, pRegsIndsTmp]

# output mRNA estimates for regulators without TFA
noPriorRegs = setdiff(potRegs_mRNA,pRegsNoTfa)
#expInds = [x for x in potRegMat_mRNA if !(x in pRegsNoTfa)]
expInds = findall(in(noPriorRegs), potRegs_mRNA)
noPriorRegsMat = potRegMat_mRNA[expInds,:]

println("Case 2")
## Case 2: prior-based TFA is used
# Check whether there were degenerate TFs and outputs from e.g.,
# mergeDegenreatePriorTFs.py exist
mergedTFsExist = 1
mergedFile = replace(priorFile,".tsv" =>"_merged.tsv")
mergedTFs = replace(priorFile,".tsv" => "_mergedTFs.txt")
file1 = isfile(mergedFile)
file2 = isfile(mergedTFs)
if(file1 == false || file2 == false)   
    mergedTFsExist = 0
end


if mergedTFsExist == 1
    mtIn = open(mergedTFs)
    C = readdlm(mtIn,'\t','\n', skipstart=0)
    #C = CSV.File(mtIn, delim="\t", header=0)
    mergedTFs = C[:,1]
    individualTFs = C[:,2] 
    mergedTFs = convert(Vector{String}, mergedTFs)
    individualTFs = convert(Vector{String}, individualTFs)
    totMergedSets = length(individualTFs);
    keepMergedTFs = []; # keep track of merged TF names to keep
    for mind = 1:totMergedSets
        currSet = split(individualTFs[mind],", ")
        usedTfs = intersect(currSet,potRegs)
        if length(usedTfs) > 0 
            keepMergedTFs = [keepMergedTFs; mind]
        end
    end
    if length(keepMergedTFs) > 0 # add merged potential regulators to our list       
        potRegs = union(potRegs,mergedTFs[keepMergedTFs])
        priorFile = mergedFile
        # regulator list and target genes
        fid = open(priorFile)
        # get first line and see what regulators we have    
        tline = readline(fid)
        pRegsTmp = split(tline,"\t")
        if pRegsTmp[1] == ""
            pRegsTmp = pRegsTmp[2:length(pRegsTmp)]
        end
        totPRegs = length(pRegsTmp)        
        close(fid)
        # get the rest of the data using textscan
        fid = open(priorFile)
        C = readdlm(fid,'\t',skipstart=0)
        pTargsTmp = C[:,1]
        if pTargsTmp[1] == ""
            pTargsTmp = pTargsTmp[2:length(pTargsTmp)]
        end
        pIntsTmp = C[2:end,2:end]  
    end        
end 

println("Enforce Rules on data")

## now go through and enforce minimum number of targets
## Limit prior regulators and gene targets to those included in input data (.mat)
pRegs = intersect(pRegsTmp,potRegs)
pTargs = intersect(pTargsTmp,tfaGenes)
pTargIndsTmp = findall(in(tfaGenes), pTargsTmp)
pRegIndsTmp = findall(in(potRegs), pRegsTmp)
pInts = pIntsTmp[pTargIndsTmp,pRegIndsTmp]
intsPerTf = sum((abs.(sign.(pInts))), dims=1)

## remove predictors that have fewer than the specified minimum number of targets
minTargets = max(minTargets,0)
keepRegs = Tuple.(findall(x -> x > minTargets, intsPerTf))
keepRegs = last.(keepRegs)
pInts = pInts[:,keepRegs]
pRegs = pRegs[keepRegs]

# possible that there now are some target genes with no regulators
intsPerTarg = sum(abs.(sign.(pInts)), dims = 2)
keepTargs = Tuple.(findall(x -> x > 0, intsPerTarg))
keepTargs = first.(keepTargs)
pInts = pInts[keepTargs,:]
pTargs = pTargs[keepTargs]
pTargs = convert(Vector{String},pTargs)

# make sure that target indices in prior and expression matrix
# coordinate
pTargs2 = intersect(pTargs,tfaGenes)
pTargs2Inds = Tuple.(findall(in(tfaGenes), pTargs))
pTargIndsTmp = first.(pTargs2Inds)
expTargInds = Tuple.(findall(in(pTargs), tfaGenes))
expTargInds = first.(expTargInds)
priorMatrix = pInts[pTargIndsTmp,:]
priorMatrix = convert(Matrix{Int64}, priorMatrix)
# get target gene matrix
targExp = tfaGeneMat[expTargInds,:]
targExp = convert(Matrix{Float64}, targExp)

println("Calculate TFA")
## calculate TFA, ( X = P * A, A = P \ X)
totTargs = size(priorMatrix)[1]
totPreds = size(priorMatrix)[2]


if edgeSS > 0
    tfas = zeros(edgeSS,totPreds,totConds)
    for ss = 1:edgeSS
        sPrior = zeros(Int8, totTargs,totPreds)
        for col = 1:totPreds
            currTargs = priorMatrix[:,col]
            targInds = findall(x -> x != 0, currTargs)
            totCurrTargs = length(targInds)
            # Create a vector from 1:totCurrTargs (the number of nonzero rows in the column) and shuffle it
            # Then take the first .63*totCurrTargs elements of this vector
            # Use this as the indices of targInds to create the ssample vector
            totCurrTargsVec = shuffle(collect(1:totCurrTargs))
            totCurrTargsVec = totCurrTargsVec[1:Int64(ceil(.63*totCurrTargs))]
            ssample = targInds[totCurrTargsVec]
            sPrior[ssample,col] = priorMatrix[ssample,col]
        end        
        tfas[ss,:,:] = sPrior \ targExp   
    end
    medTfas = zeros(totPreds,totConds)

    medTfas[:,:] = median(tfas, dims = 1)
    println("Median from  ", string(edgeSS), " subsamples used for prior-based TFA.")
else
    medTfas = priorMatrix \ targExp;
    println("No subsampling for prior-based TFA estimate.")
end


println("Save data")

@save outputFile pTargsNoTfa priorMatrixNoTfa pRegsNoTfa medTfas pRegs pTargs priorMatrix noPriorRegs noPriorRegsMat


end
