using Statistics
using CSV
using DelimitedFiles
using LinearAlgebra

include("../julia_fxns/partialCorrelation.jl")

function buildTRNs_mLassoStARS(instabOutMat,tfaMat,priorMergedTfsFile,
    meanEdgesPerGene,targInstability,instabSource,subsampHistPdf,trnOutMat,correlation_weight,
    outNetFileSparse, outMat, networkDir)
## buildTRNs_mLassoStARS(instabOutMat,tfaMat,meanEdgesPerGene,...
#    targInstability,instabSource,plotSubSampHist,trnOutMat,...
#    outNetFileSparse)
## GOAL: Rank TF-gene interactions according to stability (frequency 
#   of nonzero edges across subsamples + |partial correlation (TF,gene)|
#   If outNetFileSparse (file name) is supplied, this fxn will output the TRN 
#   in "sparse" format : TF, target gene, edge weight + additional edge metadata for
#   viewing with jp_gene_viz) as well as a .mat file summary file
## Reference:
# Miraldi et al. "Leveraging chromatin accessibility data for 
#   transcriptional regulatory network inference in T Helper 17 Cells"
## Author: Emily R. Miraldi, Ph.D., Divisions of Immunobiology and Biomedical
#   Informatics, Cincinnati Children's Hospital
## INPUTS:
# instabOutMat -- contains network- and gene-level instabilities,
#   lambdaRange, number of nonzero subsamples per edge (e.g., as generated
#   by estimateInstabilitiesTRN.m or estimateInstabilitiesTRNbStARS.m)
# tfaMat -- a .mat file containing the prior of TF-gene interactions as
#   well as TFA (prior-based and TF mRNA), e.g., as generated by 
#   integratePrior_estTFA.m
# priorMergedTfsFile -- if degenerate TFs were merged (e.g., by
#   mergeDegeneratePriorTFs.py in priorParsingFunctions) to enable
#   prior-based TFA calculation, supply the two-column, tab-delimited file,
#   where column 1 = merged TF names as in the merged TF prior, and column
#   2 = individual TF names, separated by ", " e.g., as in
#   Th17_example/inputs/priors/ATAC_allTh_mergedTfs.txt:
#         Mesp1_Mesp2     Mesp1, Mesp2
#         Npas1_Npas3...  Npas1, Npas3, Sim1, Sim2
#         Nr1h2_Nr1h3     Nr1h2, Nr1h3   
#   NOTE: provide an empty string '' if there were no degenerate TFs in the
#   prior, this file does not exist, or TF mRNA was used for TFA
# meanEdgesPerGene -- used to calculate quantiles, total number of edges =
#   number of gene models X meanEdgesPerGene
# targInstability -- instability cutoff of interest, belongs to range 
#   (0,.5]
# instabSource -- source of instability estimates, two options:
#   'Network'  --> for network-wide stability estimates
#   'Gene' --> stability based on each gene model separately
# trnOutMat -- name for output .mat containing ranks, partial correlation,
#   etc., for downstream analysis (e.g., gene expression prediction)
# outNetFileSparse -- name for tab-delimited network file in "sparse" format (i.e., 
#   first three columns are TF, gene, and signed confidence + metadata,
#   including metadata to modulate edge color and other features in
#   visualization tool jp_gene_viz
#   (https://github.com/simonsfoundation/jp_gene_viz), NOTE: empty string
#   '' signals not to create this output
## OUTPUTS:
## ${outDir}/Results_lassoStARS/${quantNetFolderName} outputs:
# trnOutMat -- contains ranked lists of network edges, stabilities,
#   whether they were in the input prior, etc.
# outNetFileSparse -- (optional) 3-column network file format for visualization in 
#       jp_gene_viz, limit models to size "meanEdgesPerGene"
#        0.  Edge confidence is a quantile, where total edges is set to
#              meanEdgesPerGene * total Gene Models
#        1.  Edge thickness (in output sparse network) is proportional to 
#              edge stability: 2*(.5-instability) E [0,1] 
#        2.  Edges signs are calculated based on partial correlation

ssMatrix = load(instabOutMat, "ssMatrix")
netInstabilities = load(instabOutMat, "netInstabilities")
predictorMat = load(instabOutMat, "predictorMat")
responseMat = load(instabOutMat, "responseMat")
priorMat = load(instabOutMat, "priorMat")
targGenes = load(instabOutMat, "targGenes")
allPredictors = load(instabOutMat, "allPredictors")
totSS = load(instabOutMat, "totSS")
pRegsNoTfa = load(tfaMat,"pRegsNoTfa")

totLambdas, totNetGenes, totNetTfs = size(ssMatrix)
ssOfInt = zeros(totNetGenes,totNetTfs)

## transform StARS instabilities into stabilities 
if length(findall("Gene", instabSource)) > 0

elseif length(findall("Network", instabSource)) > 0
    println("Network instabilities detected.")
    # find the single lambda corresponding to the cutoff
    devs = abs.(netInstabilities .- targInstability)
    globalMin = findmin(devs)
    minInds = first(Tuple(globalMin[2]))
    globalMin = globalMin[1]
    # take the largest lambda that is closest to targInstability
    minInd = minInds[end]
    if minInd == 1
        println("Minimum lambda was used for maximum instability ", string(netInstabilities[minInd]), " to reach target cut = ", string(targInstability), ".")
    elseif minInd == totLambdas
        println("Maximum lambda was used for minimum instability ", string(netInstabilities[minInd]), " to reach target cut = ", string(targInstability), ".")
    end
    ssOfInt[:,:] = ssMatrix[minInd,:,:]
else
     error("instabSource not recognized, should be either Gene or Network.")
end

# ssMatrix has infinity entries to mark illegal TF-gene interactions
# (e.g., TF mRNA TFA cannot be used to predict TF gene expression)
ssOfIntVec = ssOfInt[:]
ssOfIntVec[isinf.(ssOfIntVec)] .= 0
ssOfInt = reshape(ssOfIntVec,totNetGenes,totNetTfs)



# will want to calculate partial correlations further below
inPriorMat = sign.(abs.(priorMat))

## Rank edges based on stability at instability cutoff
println("Ranking Edges")
totInts = totNetGenes * totNetTfs 
targs0 = repeat(targGenes, totNetTfs, 1)
regs1 = repeat(permutedims(allPredictors), totNetGenes,1)
regs0 = reshape(regs1,totInts,1)
## only keep nonzero & finite edge subsample counts
rankTmp = ssOfInt[:]
keepInds = findall(x -> x != 0 && x != Inf, rankTmp) # keep nonzero, remove infinite values (e.g., corresponding to TF-TF edges when TF mRNA used for TFA)
rankTmp2 = rankTmp[keepInds]
inds = reverse(sortperm(rankTmp2))
rankings = sort(rankTmp2,rev=true)
regs = regs0[keepInds[inds]]
targs = targs0[keepInds[inds]]
totInfInts = length(rankings)


## convert the stabilities to quantiles according to meanEdgesPerGene
println("Calculating quantiles, assuming mean of ", string(meanEdgesPerGene), " TFs/gene.")
totQuantEdges = length(unique(targs))*meanEdgesPerGene
quantiles = zeros(totQuantEdges,1)
if totInfInts > totQuantEdges
    ranks4quant = rankings[1:totQuantEdges] # note there might be stability
    # ties at the end of the ranks4quant matrix
    println("Total networks edges (", string(totInfInts), ") > meanEdgesPerGene (", string(meanEdgesPerGene), ", ", string(totQuantEdges), ").") 
else
    ranks4quant = zeros(totQuantEdges,1)
    ranks4quant[1:totInfInts] = rankings
    println("Total networks edges (", string(totInfInts), ") < meanEdgesPerGene (", string(meanEdgesPerGene), ", ", string(totQuantEdges), ").") 
end

uniRanks = sort(setdiff(unique(ranks4quant),[0]),rev = true);
totRanks = length(uniRanks)
totVals = 0
for rind = 1:totRanks
    rankInds = findall(x -> x==uniRanks[rind], ranks4quant)
    totVals = totVals + length(rankInds);
    quantiles[rankInds] .= 1 - totVals/totQuantEdges;
end
totQuantEdges = length(findall(x -> x > 0, quantiles))  

## take what's in the meanEdgesPerGene network and get partial correlations
allCoefs = zeros(totNetGenes,totNetTfs)
allQuants = zeros(totNetGenes,totNetTfs)
allStabsTest = ssOfInt
keptTargs = permutedims(targs[1:totQuantEdges])
uniTargs = unique(keptTargs)
totUniTargs = length(uniTargs)
tfsPerGene = zeros(totUniTargs,1)
for targ = 1:totUniTargs
    currTarg = uniTargs[targ]
    targRankInds = last.(Tuple.(findall(x -> x == currTarg, keptTargs)))
    currRegs = regs[targRankInds]
    targInd = last.(Tuple.(findall(x -> x == currTarg, targGenes)))
    tfsPerGene[targ] = length(targRankInds)
    tfsPerGene = Int.(tfsPerGene)
    vals = intersect(allPredictors,currRegs)
    inds = Tuple.(findall(in(vals), allPredictors))
    regressIndsMat = first.(inds)
    rankVecInds = findall(in(vals),currRegs)
    currTargVals = vec(transpose(responseMat[targInd,:]))
    currPredVals = transpose(predictorMat[regressIndsMat,:])
    combTargPreds = vcat(currTargVals', currPredVals')'
    combTargPreds = permutedims(combTargPreds')
    prho = partialCorrelationMat(combTargPreds; first_vs_all = true)
    prho = prho[2:end]
    prho = vec(prho)

    if length(findall(x -> x == NaN, prho)) == 0  # make sure there weren't too many edges, 
        allCoefs[targInd,regressIndsMat] = prho
    else
        println(currTarg, " pcorr was singular, # TFs = ", string(length(regressIndsMat)))
    end   
    allQuants[targInd,regressIndsMat] = quantiles[targRankInds[rankVecInds]]
    #allStabsTest[targInd,regressIndsMat] = rankings[targRankInds[rankVecInds]] + round.(abs.(prho),digits = 2)
    allStabsTest[targInd,regressIndsMat] = allStabsTest[targInd,regressIndsMat] + (correlation_weight .* transpose(round.(abs.(prho),digits = 4)))
end

# save stabilities, targs and TFs before merging -- needed for
# R^2_pred, LO analysis
allStabsMergedTFs = allStabsTest[:]
keepInds = findall(x -> x != 0 && x != Inf, allStabsMergedTFs) 
allStabsMergedTFs = allStabsMergedTFs[keepInds]

mergeTfLocVec = zeros(totNetTfs) # for keeping track of merged TFs (needed for partial correlation calculation)

if priorMergedTfsFile != "" # there could be merged TFs
    println("Found Merged Prior")
    fid = open(priorMergedTfsFile)
    C = readdlm(fid,'\t',skipstart=0)
    tmergePredTfs = C[:,1]
    tmergeVals = C[:,2]
    close(fid)
    # convert the raw regulators into TFs, if possible
    # will basically duplicate edges for merged TFs so that they
    # will overlap with the GS
    totMerged = length(tmergeVals)
    rmInds = []        # remove merged TFs from regulators
    addRegs = []
    addInts = []
    addCoefs = []
    addPMat = []
    addPredMat = []
    addLoc = []
    addQuants = []
    for mind = 1:totMerged
        mTf = tmergePredTfs[mind]
        inputLocs = findall(x -> x == mTf,allPredictors)
        totMInts = length(inputLocs) # number of interactions for merged TF
        rmInds = [rmInds; inputLocs];
        if length(inputLocs) > 0
            indTfs = intersect(permutedims(split(tmergeVals[mind],", ")),pRegsNoTfa); # intersect ensures that TF was a potential regulator (e.g., based on gene expression)
            totIndTfs = length(indTfs)
            for indt = 1:totIndTfs
                indTf = indTfs[indt]
                append!(addRegs, fill(indTf, 1))
                append!(addInts, allStabsTest[:,inputLocs])
                append!(addPMat, inPriorMat[:,inputLocs])
                append!(addQuants, allQuants[:,inputLocs])
                append!(addCoefs, allQuants[:,inputLocs])
                append!(addPredMat, predictorMat[inputLocs,:])
                append!(addLoc, mind)
                #addRegs = [addRegs; repeat(indTf, totMInts)]
                #addRegs = strvcat(addRegs,strvcat(repmat(indTf,totMInts,1)))
                #addInts = [addInts,allStabsTest[:,inputLocs]]
                #addPMat = [addPMat,inPriorMat[:,inputLocs]]
                #addQuants = [addQuants, allQuants[:,inputLocs]]
                #addQuants = [addQuants, (allQuants[:])[inputLocs]]
                #addCoefs = [addCoefs, allQuants[:,inputLocs]]
                #addPredMat = [addPredMat ; predictorMat[inputLocs,:]]
                #addLoc = [addLoc; mind]
            end                
         end
    end    
    println("Total of ", string(length(rmInds)), " TFs expanded.")
    keepInds = setdiff(1:totNetTfs,rmInds)
    # remove merged TFs and add individual TFs
    if length(addRegs) > 0
        #allPredictors = vcat(vcat(allPredictors[keepInds]),addRegs)
        #allStabsTest = [allStabsTest[:,keepInds] addInts]
        #allCoefs = [allCoefs[:,keepInds] addCoefs]
        #allQuants = [allQuants[:,keepInds] addQuants]
        #inPriorMat = [inPriorMat[:,keepInds] addPMat]
        #predictorMat = [predictorMat[keepInds,:]; addPredMat]   
        #mergeTfLocVec = [mergeTfLocVec[keepInds]; addLoc]
        allPredictors = collect(allPredictors[keepInds])
        append!(allPredictors, addRegs)
        allStabsTest = hcat(allStabsTest[:,keepInds], reshape(addInts, size(allStabsTest)[1], Int(size(addInts)[1] / size(allStabsTest)[1])))
        allCoefs = hcat(allCoefs[:,keepInds], reshape(addCoefs, size(allStabsTest)[1], Int(size(addInts)[1] / size(allStabsTest)[1])))
        allQuants = hcat(allQuants[:,keepInds], reshape(addQuants, size(allStabsTest)[1], Int(size(addInts)[1] / size(allStabsTest)[1])))
        inPriorMat = hcat(inPriorMat[:,keepInds], reshape(addPMat, size(inPriorMat)[1], Int(size(addPMat)[1] / size(inPriorMat)[1])))
        predictorMat = vcat(predictorMat[keepInds, :], reshape(addPredMat, Int((size(addPredMat)[1]) / size(predictorMat)[2]), size(predictorMat)[2]))
        append!(mergeTfLocVec, addLoc)
    end
else
    println("No merged TFs file found.")        
end

## re-rank based on possibly de-merged TFs
rankings = allStabsTest[:]       
coefVec = allCoefs[:]

inPriorVec = inPriorMat[:]
totNetTfs = length(allPredictors)
totInts = totNetGenes * totNetTfs
targs = repeat((targGenes),totNetTfs,1)
regs1 = repeat(permutedims(allPredictors),totNetGenes,1)
regs = reshape(regs1,totInts,1)

rankings = convert(Vector{Float64}, rankings)
coefVec = convert(Vector{Float64}, coefVec)
inPriorVec = convert(Vector{Float64}, inPriorVec)
predictorMat = convert(Matrix{Float64}, predictorMat)
allStabsTest = convert(Matrix{Float64}, allStabsTest)
allCoefs = convert(Matrix{Float64}, allCoefs)
allQuants = convert(Matrix{Float64}, allQuants)
inPriorMat = convert(Matrix{Float64}, inPriorMat)

## only keep nonzero rankings
keepRankings = findall(x -> x != 0 && x != Inf, rankings)
indsMerged = sortperm(rankings[keepRankings])
indsMerged = reverse(indsMerged)

# update info sources
rankings = rankings[keepRankings[indsMerged]]
coefVec = coefVec[keepRankings[indsMerged]]
inPriorVec = inPriorVec[keepRankings[indsMerged]]    
regs = regs[keepRankings[indsMerged]]
targs = targs[keepRankings[indsMerged]]
totInfInts = length(rankings)

totQuantEdges = length(unique(targs))*meanEdgesPerGene
ranks4quant = rankings[1:totQuantEdges]
quantiles = zeros(length(rankings),1)
uniRanks = sort(setdiff(unique(ranks4quant),[0]),rev = true);
totRanks = length(uniRanks)
totVals = 0
for rind = 1:totRanks
    rankInds = findall(x -> x==uniRanks[rind], ranks4quant)
    totVals = totVals + length(rankInds);
    quantiles[rankInds] .= 1 - totVals/totQuantEdges;
end

## Color calculations for JP-Gene-Viz 
minRank = minimum(rankings)
maxRank = maximum(rankings)
rankRange = maxRank - minRank
medBlue = [0, 85, 255]
medRed = [228, 26, 28]
lightGrey = [217, 217, 217]
strokeWidth = zeros(length(rankings))
strokeVals = Vector{String}()
strokeDashArray = Vector{String}()
signedQuantile = zeros(length(rankings))
for ii in 1:length(rankings)
    strokeWidth[ii] = 1 + (rankings[ii] - minRank) / rankRange
    currPrho = abs(coefVec[ii])
    color = currPrho * medRed + (1-currPrho)*lightGrey
    colorString = "rgb(" * string(floor(Int, round(color[1]))) * "," * string(floor(Int, round(color[2]))) * "," * string(floor(Int, round(color[3]))) * ")"
    push!(strokeVals, colorString)
    signedQuantile[ii] = sign(coefVec[ii]) * quantiles[ii]
    if inPriorVec[ii] == 1
        push!(strokeDashArray, "None")
    else
        push!(strokeDashArray, "2,2")
    end
end

networkMatrix = hcat(regs, targs, signedQuantile, rankings, coefVec, strokeVals, strokeWidth, strokeDashArray)
networkMatrixSubset = hcat(regs[1:totQuantEdges], targs[1:totQuantEdges], signedQuantile[1:totQuantEdges], rankings[1:totQuantEdges], coefVec[1:totQuantEdges], strokeVals[1:totQuantEdges], strokeWidth[1:totQuantEdges], strokeDashArray[1:totQuantEdges])

colNames = "TF\tGene\tsignedQuantile\tStability\tCorrelation\tstrokeVals\tstrokeWidth\tstrokeDashArray\n"

open(networkDir * "/targs.txt","w") do io 
    writedlm(io, targs)
end
open(networkDir * "/regs.txt","w") do io 
    writedlm(io, regs)
end
open(networkDir * "/rankings.txt","w") do io
    writedlm(io, rankings)
end
open(networkDir * "/edges.txt","w") do io
    write(io, colNames)
    writedlm(io, networkMatrix)
end
open(networkDir * "/edges_subset.txt","w") do io   
    write(io, colNames)
    writedlm(io, networkMatrixSubset)
end

@save outMat predictorMat responseMat mergeTfLocVec allStabsTest allCoefs allQuants inPriorMat targGenes allPredictors allStabsMergedTFs regs targs rankings coefVec quantiles inPriorVec instabSource


end
