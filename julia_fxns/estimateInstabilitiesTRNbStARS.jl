using JLD2
using DelimitedFiles
include("../julia_fxns/getMLassoStARSlambdaRangePerGene.jl")
include("../julia_fxns/getMLassoStARSinstabilitiesPerGeneAndNet.jl")

function estimateInstabilitiesTRNbStARS(geneExprMat,tfaMat,lambdaBias,tfaOpt,
    totSS,targetInstability,lambdaMin,lambdaMax,totLogLambdaSteps,subsampleFrac,
    instabOutMat,leaveOutSampleList,bStarsTotSS,extensionLimit, priorFile_penalties)
## estimateInstabilitiesTRNbStARS(geneExprMat,tfaMat,lambdaBias,tfaOpt,...
#c    totSS,targetInstability,lambdaMin,lambdaMax,totLogLambdaSteps,subsampleFrac,...
#     instabOutMat,leaveOutSampleList,bStarsTotSS,extensionLimit)
## estimateInstabilitiesMLassoStars(path2data,priorName,priorTfaFile,lambdaBiases,...
#     tfaOpt,cvSubFolder,totSS,kfoldCvs)
## Goal: Estimate mLASSO-StARS instabilities for given input prior, prior 
# reinforcement, TFA methods, and target instability. Script relies on
# upper and lower bounds for lambda ranges derived from bStARS to speed 
# computation time (see reference below.)
## References:
# Miraldi et al. "Leveraging chromatin accessibility data for 
#   transcriptional regulatory network inference in T Helper 17 Cells"
# Glmnet for Matlab (2013) Qian, J., Hastie, T., Friedman, J., Tibshirani, 
#   R. and Simon, N. -- http://www.stanford.edu/~hastie/glmnet_matlab/
# Liu, Roeder, Wasserman (2010) "Stability Approach to Regularization 
#   Selection (StARS) for High Dimensional Graphical Models". Adv. Neural.
#   Inf. Proc.
# Muller, Kurtz, Bonneau. "Generalized Stability Approach for Regularized
#   Graphical Models". 23 May 2016. arXiv.
## Author: Emily R. Miraldi, Ph.D., Divisions of Immunobiology and Biomedical
#   Informatics, Cincinnati Children's Hospital
## INPUTS:
# geneExprMat -- a .jld file containing gene expression data, gene lists
#   (target genes, potential regulators,...), e.g., as generated by
#   importGeneExpGeneLists.m
# tfaMat -- a .jld file containing the prior of TF-gene interactions as
#   well as TFA (prior-based and TF mRNA), e.g., as generated by 
#   integratePrior_estTFA.m
# lambdaBias -- a fractional lambda penalty that a TF-gene interaction in 
#   the prior matrix will have (e.g., penalty term for prior-supported edge
#   is reduced to bias * lambda, where lambda corresponds to the "reference" 
#   penalty applied to edges not in the prior), belongs to range [0,1]
# tfaOpt -- two options recognized:
#   "" --> TFA based on target gene and priors is used, 
#   "_TFmRNA" --> TF based on TF mRNA levels are used
# totSS -- total number of subsamples for the final instability estimates
# targetInstability -- instability cutoff of interest, belongs to range 
#   (0,.5]
# lambdaMin -- initial guess for lambda lower bound containing the lambda
#   that corresponds to the targetInstability, [0, infinity), note glmnet
#   is very slow for lambda < .01
# lambdaMax -- initial guess for lambda lower bound containing the lambda
#   that corresponds to the targetInstability, [0, infinity)
# totLogLambdaSteps -- number of steps per log10 lambda range in
#   bStARS-definied lambda range
# subsampleFrac -- fraction of samples to use for subsampling. Liu et al.,
#   recommend subsample size = floor(100/sqrt(N)), where N = total samples.
#   Given that some TRN inference datasets have < 100 samples, Miraldi et
#   al, used .63*N.
# instabOutMat -- full file name and path for output .mat file, will also
#   be used as file base name for figures and .mat output from bStARS
#   parameter search
# leaveOutSampleList -- a text file, where each line corresponds to a
#   sample condition to be left-out of the inference procedure (e.g., for
#   the purposes of cross-validation)
# bStarsTotSS -- the number of subsamples used to define lambda upper and 
#   lower bound with bStARS.  Muller et al., suggest 2, but a slightly
#   higher number of subsamples (e.g., 5) for bStARS bound derivation can 
#   lead to a tighter lower bound and speed computation overall
# extensionLimit -- in the event that the target instability is outside of
#   user provided [lambdaMin, lambdaMax] range, the range will be extended
#   by an order of magnitude (in the needed direction) up to extensionLimit
#   number of times
## OUTPUTS:
# instabOutMat -- contains network- and gene-level instabilities,
#   lambdaRange, number of nonzero subsamples per edge (used to rank
#   TF-gene interactions by subsequent scripts)
# instabOutMat.fig + .pdf -- showing network- and gene-level instabilities
#   as a function of final lambda range
# instabOutMat_bStARS -- contains bStARS-derrived upper and lowerbounds for
#   network- and gene-level instabilities
# instabOutMat_bStARS.fig + .pdf -- visualization of upper and lower bounds
#   on target instability as a function of lambda
## NOTE: Here edges in the prior are treated in a binary manner (present, 
# nonzero, or absent, zero). This code could be modified to include
# real-valued prior edge confidences.


## load gene expression and TFA
conditionsc = load(geneExprMat, "conditionsc")
targGeneMat = load(geneExprMat, "targGeneMat")
targGenes = load(geneExprMat, "targGenes")
totSamps = size(targGeneMat,2)
responseMat = targGeneMat
responseMat = convert(Matrix{Float64}, targGeneMat)
pRegsNoTfa = load(tfaMat, "pRegsNoTfa")
pTargsNoTfa = load(tfaMat, "pTargsNoTfa")
pRegs = load(tfaMat, "pRegs")
pTargs = load(tfaMat, "pTargs")
priorMatrix = load(tfaMat, "priorMatrix")
priorMatrixNoTfa = load(tfaMat, "priorMatrixNoTfa")
medTfas = load(tfaMat, "medTfas")
potRegs_mRNA = load(geneExprMat, "potRegs_mRNA")
potRegMat_mRNA = load(geneExprMat, "potRegMat_mRNA")

### Create new prior matrix that contains only the relvant genes and TFs. 

# if not using TFA, set pRegs, pTargs, and prior matrix to the correct form. The difference
# is whether to use all TFs/targs in the prior or only the ones included in potRegs list. This
# would be to avoid accidentally using TFs that we dont have expression data for
if tfaOpt != ""
    println("noTfa option")
    pRegs = pRegsNoTfa;
    pTargs = pTargsNoTfa;
    priorMatrix = priorMatrixNoTfa;
end
# TFs in potRegs that have expression data that arent in prior. Get the index for these TFs 
# in the TF expression matrix
uniNoPriorRegs = setdiff(potRegs_mRNA, pRegs)
uniNoPriorRegInds = findall(in(uniNoPriorRegs), potRegs_mRNA)

# allPredictors include both the pRegs and the potRegs that wernt in prior
allPredictors = vcat(pRegs, uniNoPriorRegs)
totPreds = length(allPredictors)

# Create new prior matrix that contains target genes in the same order as targGenes. If using
# TFA, missing TFs not in prior that we have expression data for
targGeneInds = findall(in(pTargs), targGenes)
priorGeneInds = findall(in(targGenes), pTargs)
totTargGenes = length(targGenes)
totPRegs = length(pRegs)
priorMat = zeros(totTargGenes,totPreds)
priorMat[targGeneInds,1:totPRegs] = priorMatrix[priorGeneInds,:]

# predictorMat will be TFA (when available) and TFmRNA when TFA not available    
predictorMat = [medTfas; potRegMat_mRNA[uniNoPriorRegInds,:]]
# If not using TFA, just set predictorMat to mRNA
if tfaOpt != "" # use the mRNA levels of TFs
    currPredMat = zeros(totPreds,totSamps)
    for prend = 1:totPreds
        prendInd = findall(x -> x==allPredictors[prend],potRegs_mRNA)
        currPredMat[prend,:] = potRegMat_mRNA[prendInd,:]
    end            
    predictorMat = currPredMat
    println("TF mRNA used.")
end

# priorWeight for a TF-Gene pair will be 1 if interaction not in prior and 1-lambdaBias if
# interaction is in prior
priorWeightsMat = ones(totTargGenes,totPreds)
lambdaSort = sortperm(lambdaBias)
lambdaBias = lambdaBias[lambdaSort]
priorFile_penalties = priorFile_penalties[lambdaSort]
for (file, lambda) in zip(priorFile_penalties, lambdaBias)
    fid = open(file)
    C = readdlm(fid,'\t','\n', skipstart=0)
    pRegsTmp = C[1,:]
    pRegsTmp = pRegsTmp[2:end]
    pRegsTmp = convert(Vector{String}, pRegsTmp)
    C = C[2:end,:]
    pTargsTmp = C[:,1]
    pTargsTmp = convert(Vector{String}, pTargsTmp)
    pIntsTmp = C[:,2:end]

    pTargsTmp_inds = [findfirst(==(x), pTargsTmp) for x in targGenes if x in pTargsTmp]
    pTargsTmp = [x for x in targGenes if x in pTargsTmp]
    pRegsTmp_inds = [findfirst(==(x), pRegsTmp) for x in allPredictors if x in pRegsTmp]
    pRegsTmp = [x for x in allPredictors if x in pRegsTmp]
    pIntsTmp = pIntsTmp[pTargsTmp_inds, pRegsTmp_inds]

    targInds = [findfirst(==(x), targGenes) for x in pTargsTmp if x in targGenes]
    regsInds = [findfirst(==(x), allPredictors) for x in pRegsTmp if x in allPredictors]
    WeightMat_tmp = ones(length(pTargsTmp),length(pRegsTmp)) .- (1-lambda)*abs.(sign.(pIntsTmp))

end
priorWeightsMat = ones(totTargGenes,totPreds) - (1-lambdaBias)*abs.(sign.(priorMat))



if tfaOpt != ""
    ## set lambda penalty to infinity for positive feedback edges where TF 
    # mRNA levels serves both as gene expression and TFA estimate
    for pr = 1:totPreds
        targInd = findall(x -> x==allPredictors[pr], targGenes)
        if length(targInd) > 0 # set lambda penalty to infinity, avoid predicting a TF's mRNA based on its own mRNA level
            priorWeightsMat[targInd,pr] .= Inf # i.e., target gene is its own predictor
        end
    end    
else # have to set prior inds to zero for TFs in TFA that don't have prior info
    for pr = 1:totPreds        
        if sum(abs.(priorMat[:,pr])) == 0 # we have no target edges to estimate TF's TFA
            targInd = findall(x -> x==allPredictors[pr], targGenes)
            if length(targInd) > 0 # And TF is in the predictor set
                priorWeightsMat[targInd,pr] .= Inf
            end
        end
    end
end


## Check whether to use full gene expression matrix or exclude leave-out set 
if leaveOutSampleList != ""
    println("Leave-out set detected: ", leaveOutSampleList)
    # get leave-out set of samples
    fin = open(leaveOutSampleList)
    C = readdlm(fin,skipstart=0)
    C = convert(Matrix{String}, C)
    close(fin)
    testInds = Tuple.(findall(in(C), conditionsc))
    testInds = first.(testInds)
    trainInds = setdiff(1:totSamps,testInds)
else        
    println("Full gene expression matrix used.")
    trainInds = 1:totSamps # all training samples used
    testInds = []
end
subsampleSize = floor(subsampleFrac*length(trainInds))
subsampleSize = convert(Int64, subsampleSize)

## bStARS to narrow lambda range around target instability
println("Estimating lambda bounds for target instability with getMLassoStARSlambdaRangePerGene.jl")
bStarsTotSS = 5;  # note bStARS authors recommend 2 subsamples, we reduce search space 
# further by using 5 subsamples at relatively small cost early on
bStarsLogLambdaStep = 10;
# Determine the lambda levels to test
lamLog10step = 1/bStarsLogLambdaStep
logLamRange =  log10(lambdaMin):lamLog10step:log10(lambdaMax)
lambdaRange = 10 .^ (logLamRange)

# Calculate bStARS lambda range
minLambdas, maxLambdas, maxedOut, notSmallEnough, minLambdaNet, maxLambdaNet, maxOutNet, minOutNet, netInstabilitiesLb, netInstabilitiesUb,
    instabilitiesLb, instabilitiesUb = getMLassoStARSlambdaRangePerGene(predictorMat[:,trainInds],responseMat[:,trainInds],
    priorWeightsMat,lambdaRange,targetInstability,targetInstability,subsampleSize,bStarsTotSS)

# If target instability is never reached for certain genes, extend the lambda range and then
# recalculate instabilities
needNewRange = maxOutNet + minOutNet
extended = 0
while needNewRange >= extensionLimit && extended < extensionLimit
    if maxOutNet > 0
        currLambdaMax = lambdaMax*10
        lambdaMax = currLambdaMax
    else
        currLambdaMax = lambdaMax
    end
    if minOutNet > 0
        currLambdaMin = lambdaMin/10
        lambdaMin = currLambdaMin
    else
        currLambdaMin = lambdaMin
    end
    logLamRange =  log10(currLambdaMin):lamLog10step:log10(currLambdaMax)
    lambdaRange = 10 .^ logLamRange
    minLambdas, maxLambdas, maxedOut, notSmallEnough, minLambdaNet, maxLambdaNet, maxOutNet, minOutNet, netInstabilitiesLb, netInstabilitiesUb,
        instabilitiesLb, instabilitiesUb = getMLassoStARSlambdaRangePerGene(predictorMat[:,trainInds],responseMat[:,trainInds],
        priorWeightsMat,lambdaRange,targetInstability,targetInstability,subsampleSize,bStarsTotSS)
    extended = extended + 1   
    needNewRange = maxOutNet + minOutNet
    println("Extended lambda range " , string(extended) , " time(s).")
end        

println("For target instability = ", string(targetInstability))
println("Min lambda = ", string(minLambdaNet), ", Max lambda = ", string(maxLambdaNet))

## get instabilities
println("Estimating instabilities with getMLassoStARSinstabilitiesPerGeneAndNet.jl")
lamLog10step = 1/totLogLambdaSteps
logLamRange =  log10(minLambdaNet):lamLog10step:log10(maxLambdaNet)
lambdaRange = 10 .^ logLamRange

# Calculate instabilities for new lambda range

geneInstabilities,netInstabilities,ssMatrix = getMLassoStARSinstabilitiesPerGeneAndNet(predictorMat,responseMat,priorWeightsMat,lambdaRange,subsampleSize, totSS)

# geneInstabilities: (Gene x Lambda) gene instabilitiy values for each lambda level
# netInstabilities: total network instabilitiy at each lambda (vector)
# ssMatrix: (lambda x gene x TF) subsample number of each TF-gene pair for each lambda
# predictorMat: (Gene x TF) either TFA (+ missing TFmRNA) or just TFmRNA
# responseMat: (Gene x Sample) target gene expression matrix
# priorMat: (Gene x TF) prior matrix. First set of columns contain TFs that had prior info. Second 
	# set contain TFs that arent in prior and are columns of zeros
# lambdaBias: (Constant) peanlty for edge not being prior supported
# lambdaRange: (Vector) lambda values from range determined by bStARS
# trainInds: Samples used for training
# subsampleSize: (Constant) number of pseudobulks to use in each subsample
# totSS: (Constant) total number of subsamples
# targGenes: (Vector) target genes
# priorWeightsMat: (Gene x TF) Peanalties matrix
# allPredictors: all potRegs with or without prior data
# conditionsc: (vector) conditions list


@save instabOutMat geneInstabilities netInstabilities ssMatrix predictorMat responseMat priorMat lambdaBias lambdaRange trainInds subsampleSize totSS targGenes priorWeightsMat allPredictors conditionsc

end


